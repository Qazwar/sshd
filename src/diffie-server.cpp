/* diffie-server.cpp
 * Performs the server side of the diffie-hellman keyexchange.
 *
 * Copyright (c) 2006-2009 Magnus Leksell, all rights reserved.
 */

#include "CDiffieHellman.h"
#include "CTransport.h"
#include "messages.h"
#include "debug.h"
#include "errors.h"
#include "ArrayStream.h"
#include "sshd.h"

namespace ssh
{
    /* CDiffieHellman::ServerKeyExchange
     * Performs the Diffie-Hellman keyexchange.
     */
    int CDiffieHellman::ServerKeyExchange(
        CHostKey * hostkey, 
        bool guess)
    {
        byte id;
        std::vector<byte> signature;
    
        /* If the client guessed correctly the first exchange packet is
         * included in the KEXINIT packet, otherwise we need to wait for the
         * client to send the first packet.
         */

        if( !guess ) { 
            /* The client didn't guess or the guess was incorrect */
            if( m_ts->readPacket() != sshd_OK ) {
                sshd_Log(sshd_EVENT_FATAL, "Failed to read initial keyexchange packet.");
                return ERR_FAILED;
            }
        }

        m_e = new CBigInt();
        if( !m_e )
            return ERR_FAILED;

        /* read the contents of the packet */
        if( !m_ts->readByte(id) ||      /* read the packet identifier */
            (id != SSH_MSG_KEXDH_INIT) ||   /* verify that this is a correct packet */
            !m_e->read(*m_ts) )         /* read the public value generated by the client */
        { 
            /* failed to read the client's message */
            sshd_Log(sshd_EVENT_FATAL, "Failed to parse KEXDH message.");
            return ERR_FAILED;
        }

        /* generate the server keys */
        if( !GenerateKeys( true ) ) {
            sshd_Log(sshd_EVENT_FATAL, "Failed to generate keys.");
            return ERR_FAILED;
        }

        /* check if the public key is valid */
        if( !validPublicKey(m_e) ) {
            sshd_Log(sshd_EVENT_FATAL, "Public not valid.");
            return ERR_FAILED;
        }

        /* compute the shared secret */
        if( !ComputeSecret(*m_e) ) {
            DBG("Failed to calculate the shared secret.");
            return ERR_FAILED;
        }

        /* calculate the exchange hash */
        if( !ComputeExchangeHash(m_exchange, hostkey) ) {
            sshd_Log(sshd_EVENT_FATAL, "Failed to calculate exchange hash.");
            return ERR_FAILED;
        }

        
        if( !Sign(hostkey, m_exchange, signature) ) {
            sshd_Log(sshd_EVENT_FATAL, "Failed to sign exchange hash.");
            return ERR_FAILED;
        }

        m_ts->newPacket();

        /*
         * Write the reply
         */
        if( !m_ts->writeByte(SSH_MSG_KEXDH_REPLY) ||
            !hostkey->WriteKeyblob( *m_ts ) ||
            !m_f->write( *m_ts ) || 
            !hostkey->WriteSignature( *m_ts, signature ) )
        {
            sshd_Log(sshd_EVENT_FATAL, "Failed to write KEXDH reply.");
            return ERR_FAILED;
        }

        /* send the packet */
        if( m_ts->sendPacket() != OK ) {
            sshd_Log(sshd_EVENT_FATAL, "Failed to send KEXDH reply.");
            return ERR_FAILED;
        }

        return sshd_OK;
    }
}